# Memory Rating System

## Overview
This system evaluates and scores memories for retention priority, helping the AI agent maintain the most valuable information while managing storage constraints effectively.

## Rating Criteria and Weights

### 1. Recency Score (Weight: 25%)
**Purpose**: Prioritize recent information that's likely to be relevant

#### Scoring Scale (0-100):
- **90-100**: Within last 24 hours
- **80-89**: Within last week  
- **70-79**: Within last month
- **60-69**: Within last 3 months
- **40-59**: Within last 6 months
- **20-39**: Within last year
- **0-19**: Older than 1 year

#### Decay Function:
```
score = 100 * e^(-t/τ)
where t = time since creation, τ = decay constant (30 days)
```

### 2. Importance Score (Weight: 35%)
**Purpose**: Identify information that significantly impacts code quality or user experience

#### Scoring Categories:

**Critical (90-100)**:
- Security vulnerabilities and fixes
- Breaking changes and their resolutions
- Core architectural decisions
- Performance bottlenecks and optimizations
- Data loss prevention strategies

**High (70-89)**:
- Feature implementations and their patterns
- User preference changes
- Successful debugging approaches
- Tool configuration optimizations
- Code quality improvements

**Medium (50-69)**:
- Routine bug fixes
- Style preference adjustments
- Documentation updates
- Refactoring decisions
- Learning interactions

**Low (20-49)**:
- Minor formatting changes
- Clarification questions
- Temporary workarounds
- Routine maintenance tasks
- General conversation

**Trivial (0-19)**:
- Greeting and social interactions
- Repeated information
- Failed or abandoned approaches
- Superseded decisions

### 3. Code Relevance Score (Weight: 30%)
**Purpose**: Prioritize information directly related to code and development

#### Scoring Factors:

**Direct Code Impact (80-100)**:
- Function/method implementations
- Class/module designs
- API definitions and usage
- Database schema changes
- Configuration modifications

**Development Process (60-79)**:
- Testing strategies and results
- Build and deployment procedures
- Tool usage and configuration
- Code review feedback
- Performance measurements

**Project Context (40-59)**:
- Requirements discussions
- Architecture planning
- Technology selection rationale
- Team coordination decisions
- Project timeline considerations

**General Knowledge (20-39)**:
- Programming concepts explanation
- Best practices discussion
- Industry trends and news
- Learning resources
- Theoretical discussions

**Non-Code Related (0-19)**:
- Personal conversations
- Off-topic discussions
- Administrative tasks
- Non-technical support

### 4. Utility Score (Weight: 10%)
**Purpose**: Consider how often information is referenced or proves useful

#### Usage Tracking:
- **Reference Count**: How many times memory has been retrieved
- **Success Rate**: How often retrieved memory led to successful outcomes
- **User Satisfaction**: Positive feedback when memory was applied
- **Pattern Matching**: How well memory generalizes to new situations

#### Scoring Formula:
```
utility_score = (reference_count * 10) + (success_rate * 40) + (satisfaction_rating * 30) + (generalization_score * 20)
```

## Composite Rating Calculation

### Final Score Formula:
```
final_score = (recency * 0.25) + (importance * 0.35) + (code_relevance * 0.30) + (utility * 0.10)
```

### Score Interpretation:
- **90-100**: Critical memories - retain indefinitely
- **80-89**: High priority - retain for extended periods
- **70-79**: Important memories - retain for medium term
- **60-69**: Moderate priority - retain for short-medium term
- **40-59**: Low priority - retain for short term or until space needed
- **20-39**: Minimal priority - candidate for early removal
- **0-19**: Remove unless specifically requested to retain

## Dynamic Adjustments

### Context-Sensitive Weighting
Adjust weights based on current situation:

**During Debugging Sessions**:
- Increase importance weight to 45%
- Increase code relevance weight to 35%
- Decrease recency weight to 15%
- Maintain utility weight at 5%

**During Learning/Exploration**:
- Increase recency weight to 35%
- Maintain importance weight at 35%
- Decrease code relevance weight to 20%
- Increase utility weight to 10%

**During Feature Development**:
- Maintain balanced weights as default
- Apply bonus for related feature memories
- Prioritize architectural decision memories

### User Preference Modifiers
- **Conservative User**: Increase importance weight for critical items
- **Experimental User**: Increase recency weight for latest approaches
- **Learning-Focused User**: Increase utility weight for educational content
- **Efficiency-Focused User**: Increase code relevance weight

## Memory Lifecycle Management

### Retention Thresholds
- **Immediate Removal**: Score < 20
- **Weekly Review**: Score 20-39
- **Monthly Review**: Score 40-59
- **Quarterly Review**: Score 60-79
- **Annual Review**: Score 80-89
- **Permanent Retention**: Score 90-100

### Re-evaluation Triggers
- Memory is accessed or referenced
- Related code is modified
- User provides feedback on memory relevance
- Similar patterns emerge in new code
- Project architecture changes significantly

### Batch Processing
- Rate all memories weekly
- Remove low-scoring memories in batches
- Consolidate similar high-scoring memories
- Update user preference profiles based on memory patterns
- Generate summary reports of memory evolution

## Quality Assurance

### Validation Checks
- Ensure scoring consistency across similar memories
- Validate that critical information isn't accidentally downgraded
- Check for bias in importance scoring
- Monitor for memory loss that impacts user experience

### Calibration Process
- Compare memory scores with user feedback
- Adjust weights based on long-term outcomes
- Validate against objective measures (code quality, bug rates)
- Incorporate user satisfaction metrics

### Feedback Integration
- Track when retrieved memories were helpful or unhelpful
- Adjust future scoring based on actual utility
- Learn user patterns for better importance assessment
- Refine code relevance detection based on usage patterns